#include "TIdentificator.h"
#include "massConst.h"

//______________________________________________________________________________
//
// TIdentificator
//
// An API class to extract useful information for analysis, from ROOT files
// generated by CLASTool.
//

const Double_t kFidThetaMax = 54;

// For FidThetaMin calculation for electron
const Double_t kThetaPar0[6] = { 15        , 15        ,  15       , 15        ,  13       ,  13        };
const Double_t kThetaPar1[6] = { -0.425145 , -1.02217  , -0.7837   , -1.47798  ,   3.47361 ,   3.5714   };
const Double_t kThetaPar2[6] = { -0.666294 , -0.616567 , -0.673602 , -0.647113 ,  -0.34459 ,  -0.398458 };
const Double_t kThetaPar3[6] = {  5.73077  ,  5.51799  ,  8.05224  ,  7.74737  ,   8.45226 ,   9.54265  };
const Double_t kThetaPar4[6] = { 10.4976   , 14.0557   , 15.2178   , 16.7291   , -63.4556  , -22.649    };
const Double_t kThetaPar5[6] = { -1.13254  , -1.16189  , -2.08386  , -1.79939  ,  -3.3791  ,  -1.89746  };

// For parameter 0 of the FidPhiMin calculation for electron
const Double_t kFidPar0Low0[6] = {  25      ,  25        ,  25       ,  24.6345  ,  23.4731  ,  24.8599  };
const Double_t kFidPar0Low1[6] = { -12      , -12        , -12       , -12       , -12       , -12       };
const Double_t kFidPar0Low2[6] = {   0.5605 ,   0.714261 ,  0.616788 ,   0.62982 ,   1.84236 ,   1.00513 };
const Double_t kFidPar0Low3[6] = {  4.4     ,  4.4       ,  4.4      ,   4.4     ,   4.4     ,   4.4     };

// For parameter 1 of the FidPhiMin calculation for electron
const Double_t kFidPar1Low0[6] = {  2.1945   ,  4        ,  3.3352  ,  2.22769   ,  1.63143   ,  3.19807  };
const Double_t kFidPar1Low1[6] = {  1.51417  ,  1.56882  ,  2       ,  2         ,  1.90179   ,  0.173168 };
const Double_t kFidPar1Low2[6] = { -0.354081 , -2        , -2       , -0.760895  , -0.213751  , -0.1      };
const Double_t kFidPar1Low3[6] = {  0.5      ,  0.5      ,  1.01681 ,  1.31808   ,  0.786844  ,  1.6      };

// For parameter 0 of the FidPhiMax calculation for electron
const Double_t kFidPar0High0[6] = { 25       ,  25        ,  25        ,  25        ,  23.7067  ,  25       };
const Double_t kFidPar0High1[6] = { -8       , -10.3277   , -12        , -11.3361   , -12       , -11.4641  };
const Double_t kFidPar0High2[6] = {  0.479446 ,  0.380908 ,   0.675835 ,   0.636018 ,   2.92146 ,   0.55553 };
const Double_t kFidPar0High3[6] = {  4.8      ,  4.79964  ,   4.4      ,   4.4815   ,   4.4     ,   4.41327 };

// For parameter 1 of the FidPhiMax calculation for electron
const Double_t kFidPar1High0[6] = {  3.57349 ,  3.02279  ,  2.02102 ,  3.1948   ,  3.0934   ,  2.48828 };
const Double_t kFidPar1High1[6] = {  2       ,  0.966175 ,  2       ,  0.192701 ,  0.821726 ,  2       };
const Double_t kFidPar1High2[6] = { -2       , -2        , -1.70021 , -1.27578  , -0.233492 , -2       };
const Double_t kFidPar1High3[6] = {  0.5     ,  0.527823 ,  0.68655 ,  1.6      ,  1.6      ,  0.70261 };

// For FidThetaMinPiPlus calculation for pi+
const Double_t kThetaPar0PiPlus[6] = {  7.00823   ,  5.5        ,  7.06596   ,  6.32763   ,  5.5       ,  5.5      };
const Double_t kThetaPar1PiPlus[6] = {  0.207249  ,  0.1        ,  0.127764  ,  0.1       ,  0.211012  ,  0.281549 };
const Double_t kThetaPar2PiPlus[6] = {  0.169287  ,  0.506354   , -0.0663754 ,  0.221727  ,  0.640963  ,  0.358452 };
const Double_t kThetaPar3PiPlus[6] = {  0.1       ,  0.1        ,  0.100003  ,  0.1       ,  0.1       ,  0.1      };
const Double_t kThetaPar4PiPlus[6] = {  0.1       ,  3.30779    ,  4.499     ,  5.30981   ,  3.20347   ,  0.776161 };
const Double_t kThetaPar5PiPlus[6] = { -0.1       , -0.651811   , -3.1793    , -3.3461    , -1.10808   , -0.462045 };

// For parameter 0 of the FidPhiMinPiPlus calculation for pi+
const Double_t kFidPar0Low0PiPlus[6] = {  25.      ,  25.      ,  25.     ,  25.       ,  25.       ,  25.       };
const Double_t kFidPar0Low1PiPlus[6] = { -12.      , -12.      , -12.     , -12        , -12        , -12        };
const Double_t kFidPar0Low2PiPlus[6] = {   1.64476 ,   1.51915 ,   1.1095 ,   0.977829 ,   0.955366 ,   0.969146 };
const Double_t kFidPar0Low3PiPlus[6] = {   4.4     ,   4.4     ,   4.4    ,   4.4      ,   4.4      ,   4.4      };

// For parameter 1 of the FidPhiMinPiPlus calculation for pi+
const Double_t kFidPar1Low0PiPlus[6] = {  4.        ,  4.   ,  2.78427 ,  3.58539 ,  3.32277   ,  4.      };
const Double_t kFidPar1Low1PiPlus[6] = {  2.        ,  2.   ,  2.      ,  1.38233 ,  0.0410601 ,  2.      };
const Double_t kFidPar1Low2PiPlus[6] = { -0.978469  , -2.   , -1.73543 , -2.      , -0.953828  , -2.      };
const Double_t kFidPar1Low3PiPlus[6] = {  0.5       ,  0.5  ,  0.5     ,  0.5     ,  0.5       ,  1.08576 };

// For parameter 0 of the FidPhiMaxPiPlus calculation for pi+
const Double_t kFidPar0High0PiPlus[6] = {  25.      , 24.8096  , 24.8758  ,  25.       , 25.       , 25.      };
const Double_t kFidPar0High1PiPlus[6] = { -11.9735  , -8.      , -8.      , -12.       , -8.52574  , -8.      };
const Double_t kFidPar0High2PiPlus[6] = {  0.803484 ,  0.85143 ,  1.01249 ,   0.910994 ,  0.682825 ,  0.88846 };
const Double_t kFidPar0High3PiPlus[6] = {  4.40024  ,  4.8     ,  4.8     ,   4.4      ,  4.79866  ,  4.8     };

// For parameter 1 of the FidPhiMaxPiPlus calculation for pi+
const Double_t kFidPar1High0PiPlus[6] = {  2.53606  ,  2.65468  ,  3.17084 ,  2.47156 ,  2.42349  ,  2.64394 };
const Double_t kFidPar1High1PiPlus[6] = {  0.442034 ,  0.201149 ,  1.27519 ,  1.76076 ,  1.25399  ,  0.15892 };
const Double_t kFidPar1High2PiPlus[6] = { -2.       , -0.179631 , -2.      , -1.89436 , -2.       , -2.      };
const Double_t kFidPar1High3PiPlus[6] = {  1.02806  ,  1.6      ,  0.5     ,  1.03961 ,  0.815707 ,  1.31013 };

// For FidThetaMinPiMinus calculation for pi-
const Double_t kThetaPar0PiMinus[6] = { 15        , 15          , 15         , 15          , 15          , 15          };
const Double_t kThetaPar1PiMinus[6] = { 0.256111  , 7.77818E-12 , 1.7508E-12 , 1.53231E-12 , 1.55422E-12 , 2.10305E-11 };
const Double_t kThetaPar2PiMinus[6] = {-0.925423  ,-0.126147    ,-0.936497   ,-0.501064    ,-1.09188     ,-0.154682    };
const Double_t kThetaPar3PiMinus[6] = { 4.01752   , 4.72109     , 5.08905    , 4.50628     , 5.22385     , 4.03708     };
const Double_t kThetaPar4PiMinus[6] = { 3.97889   , 9.33096     , 2.98662    , 7.2551      , 3.77058     , 11.844      };
const Double_t kThetaPar5PiMinus[6] = { -0.1      ,-1.56887     ,-0.1        ,-0.644599    ,-0.1         ,-0.99065     };

// For parameter 0 of the FidPhiMinPiMinus calculation for pi-
const Double_t kFidPar0Low0PiMinus[6] = { 17.9074 ,  19.9864 , 18.5174 , 18.0998 , 18.5118 , 18.7772 };
const Double_t kFidPar0Low1PiMinus[6] = { 5.5723  ,  4.73435 , 4.75165 , 5.62361 , 6.82854 , 4.88048 };
const Double_t kFidPar0Low2PiMinus[6] = { 6       ,  6       , 6       , 6       , 2.02903 , 6       };
const Double_t kFidPar0Low3PiMinus[6] = { 1.83182 ,  1.37676 , 1.80735 , 1.42677 , 1.66004 , 1.48777 };

// For parameter 1 of the FidPhiMinPiMinus calculation for pi-
const Double_t kFidPar1Low0PiMinus[6] = { 4       , 3.61595 , 4       , 3.21066 , 3.04887 , 2.88692  };
const Double_t kFidPar1Low1PiMinus[6] = { 2       , 1.98742 , 1.32282 , 1.19544 , 2       , 2        };
const Double_t kFidPar1Low2PiMinus[6] = {-2       ,-2       ,-0.1     ,-0.1     ,-0.1     ,-2        };
const Double_t kFidPar1Low3PiMinus[6] = { 1.08515 , 0.5     , 1.6     , 1.6     , 1.6     , 0.670166 };

// For parameter 0 of the FidPhiMaxPiMinus calculation for pi-
const Double_t kFidPar0High0PiMinus[6] = { 17.283  , 18.947  , 16.6633 , 17.6381 , 17.5285 , 17.953  };
const Double_t kFidPar0High1PiMinus[6] = { 5.21953 , 4.40193 , 5.7028  , 5.33805 , 5.2995  , 4.81356 };
const Double_t kFidPar0High2PiMinus[6] = { 6       , 6       , 6       , 6       , 6       , 6       };
const Double_t kFidPar0High3PiMinus[6] = { 1.91703 , 1.49789 , 2       , 1.50883 , 1.54247 , 1.9173  };

// For parameter 1 of the FidPhiMaxPiMinus calculation for pi-
const Double_t kFidPar1High0PiMinus[6] = { 3.81808 , 3.3033  , 1.53246 , 4        , 1.63324 , 3.32424 };
const Double_t kFidPar1High1PiMinus[6] = { 2       , 1.02631 , 1.63003 , 0.331336 , 1.79676 , 2       };
const Double_t kFidPar1High2PiMinus[6] = {-2       ,-2       ,-0.1     ,-0.1      ,-0.1     ,-2       };
const Double_t kFidPar1High3PiMinus[6] = { 1.246   , 0.5     , 1.6     , 1.6      , 1.6     , 1.39931 };


// Parameters for electron vertex correction
const Double_t EZCorrPhi[6][4] = {{1.001138e+00,-3.100494e-04,-1.131647e-06,7.262749e-08},
				  {1.042637e+00,-1.320450e-03,1.347871e-05,-5.510994e-08},
				  {9.887264e-01,-2.501313e-04,3.518903e-06,-5.667033e-09},
				  {1.194961e+00,-4.382123e-03,2.878194e-05,-5.802847e-08},
				  {-3.603443e+00,5.587247e-02,-2.263823e-04,3.063620e-07},
				  {1.905879e+00,-1.138560e-02,4.561333e-05,-5.915139e-08}};

const Double_t EZCorrTheta[6][4] = {{1.006107e+00,-1.684743e-04,-5.097129e-06,1.341475e-07},
				    {1.023083e+00,-1.631997e-03,3.579478e-05,-2.375800e-07},
				    {1.028227e+00,-2.368791e-03,6.427943e-05,-5.552193e-07},
				    {1.017742e+00,-1.340332e-03,3.132880e-05,-2.051711e-07},
				    {1.004383e+00,-3.742270e-04,8.305195e-06,-3.477238e-08},
				    {9.802314e-01,1.207434e-03,-2.232902e-05,1.514160e-07}};

// Parameters for proton vertex correction
const Double_t PZCorrPhi[6][4] = {{9.980531e-01,-1.024401e-05,1.559031e-06,-2.564001e-07},
				  {1.036559e+00,-1.073372e-03,6.323100e-06,2.552849e-08},
				  {1.360636e+00,-9.320864e-03,7.384235e-05,-1.753896e-07},
				  {1.227065e+00,-4.042279e-03,1.892550e-05,-1.972506e-08},
				  {3.347034e-02,1.034365e-02,-3.796825e-05,4.864933e-08},
				  {-3.685194e+00,4.466502e-02,-1.421921e-04,1.511606e-07}};

const Double_t PZCorrTheta[6][4] = {{1.015169e+00,-6.523524e-04,1.028452e-05,-5.011510e-08},
				    {1.019702e+00,-8.498793e-04,1.230670e-05,-4.921466e-08},
				    {1.011279e+00,-4.979530e-04,6.887853e-06,-2.159848e-08},
				    {9.994830e-01,-6.658563e-05,3.900686e-06,-2.674925e-08},
				    {1.011226e+00,-6.713270e-04,1.142001e-05,-5.862320e-08},
				    {1.000103e+00,-2.867515e-05,2.087680e-06,-1.895872e-08}};



// Parameters for polar angle correction
const Float_t ThetaCorrection[6][4] = {{-6.898465e-03,-5.093691e-04,-4.437409e-05,-1.085586e-06},
				       {-3.376092e-01,1.085781e-02,-9.263794e-05,4.445614e-08},
				       {-6.039766e-01,6.016822e-03,4.450338e-05,-4.373013e-07},
				       {-3.417601e-01,2.250364e-03,1.128394e-05,-7.500616e-08},
				       {-1.426398e+00,5.806233e-03,2.420251e-05,-9.972778e-08},
				       {-3.954411e+00,1.404261e-02,4.487579e-05,-1.591096e-07}};


// Parameters for Electron momentum correction
const Float_t MomentumCorrPhi[6][4] = {{1.004202e+00,-2.944179e-04,-8.056393e-06,3.106677e-07},
				       {9.786210e-01,1.751166e-03,-3.322187e-05,1.815059e-07},
				       {2.544156e+00,-3.781600e-02,3.076627e-04,-8.299330e-07},
				       {8.231780e-01,1.628610e-03,-3.329984e-07,-1.735582e-08},
				       {8.800811e-01,1.005054e-03,-1.156577e-06,-3.696593e-09},
				       {8.303093e-01,8.954930e-04,-3.525094e-07,-2.421276e-09}};

const Float_t MomentumCorrTheta[6][4] = {{9.985268e-01,2.133621e-04,-4.617209e-06,9.834912e-09},
					 {9.888051e-01,1.103288e-03,-3.283994e-05,3.163933e-07},
					 {9.626969e-01,3.532355e-03,-1.052500e-04,1.016438e-06},
					 {1.001662e+00,1.131775e-04,-9.299734e-06,1.477322e-07},
					 {9.991608e-01,2.128315e-05,2.029786e-06,-2.236255e-08},
					 {9.843391e-01,1.502489e-03,-4.618120e-05,4.741349e-07}};

//ClassImp(TIdentificator);


TIdentificator::TIdentificator(TClasTool *CT)
      : kEbeam(5.014), kEbeam_arc(5.0094),
      kMpi(0.139570), kGOOD(-1000.), fCT(CT),
      fEVNT(0), fGSIM(0), fCCPB(0), fECPB(0), fSCPB(0), fDCPB(0),
      fPartIds(0)
{
    // Create a TIdentificator object, related to CT.
}



TIdentificator::~TIdentificator()
{
    // Default destructor for TIdentificator.

    if (fPartIds != 0) delete [] fPartIds;
}



Double_t TIdentificator::Momentum(Int_t k, Bool_t kind)
{

    // Return the full momentum for the particle in the row k of the EVNT
    // bank.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    if (kind == 0) {
        return sqrt(Px(k) * Px(k) + Py(k) * Py(k) + Pz(k) * Pz(k));
    } else {                            // Fix this in case kind != 1
        return sqrt(Px(k,1) * Px(k,1) + Py(k,1) * Py(k,1) + Pz(k,1) * Pz(k,1));
    }
}



Double_t TIdentificator::Moment(Int_t k, Bool_t kind)
{
    // Deprecated. Use Momentum.

    if (kind == 0) {
        fEVNT = (TEVNTClass *) fCT->GetBankRow("EVNT", k);
        return sqrt(fEVNT->Px * fEVNT->Px + fEVNT->Py * fEVNT->Py +
                    fEVNT->Pz * fEVNT->Pz);
    } else {                            // Fix this in case kind != 1
        fGSIM = (TGSIMClass *) fCT->GetBankRow("GSIM", k);
        return sqrt(fGSIM->Px * fGSIM->Px + fGSIM->Py * fGSIM->Py +
                    fGSIM->Pz * fGSIM->Pz);
    }
}



Double_t TIdentificator::Mass2(Int_t k)
{
    // Return the mass squared for the particle in the row k of the EVNT bank.

    return Momentum(k) * Momentum(k) * (pow(Betta(k), -2) - 1);
}



Double_t TIdentificator::ThetaLab(Int_t k, Bool_t kind)
{
    // Return the polar angle in Lab frame for the particle in the row k of
    // the EVNT bank.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    Double_t theta;

    if (kind == 0) {
        theta = acos(Pz(k) / Momentum(k));
    } else {                            // Fix this in case kind != 1
        theta = acos(Pz(k,1) / Momentum(k,1));
    }

    return theta;
}



Double_t TIdentificator::PhiLab(Int_t k, Bool_t kind)
{
    // Return the azimuthal angle in Lab frame for the particle in the row k
    // of the EVNT bank.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    Double_t phi_val;

    if (kind == 0) {
        TVector3 v3p(Px(k), Py(k), Pz(k));
        phi_val = v3p.Phi() * 180. / TMath::Pi();
    } else {
        TVector3 v3p(Px(k,1), Py(k,1), Pz(k,1));
        phi_val = v3p.Phi() * 180. / TMath::Pi();
    }

    if (phi_val < -30.)
        phi_val += 360.;
    else if (phi_val > 330.)
        phi_val -= 360.;

    return phi_val;
}



Double_t TIdentificator::ThetaVirtLab(Bool_t kind) // Check if it is correct !!!
{
    // Return the polar angle of the virtual photon in Lab frame, for the
    // particle in the row k of the EVNT bank.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    Double_t theta_virt;

    if (kind == 0) {
        theta_virt = acos((kEbeam - Momentum(0) * cos(ThetaLab(0))) /
                           (sqrt(Q2() + Nu() * Nu())));
    } else {                            // Fix this in case kind != 1
        theta_virt = acos((kEbeam - Momentum(0,1) * cos(ThetaLab(0,1))) /
                           (sqrt(Q2(1) + Nu(1) * Nu(1))));
    }

    return theta_virt;
}



Double_t TIdentificator::PhiVirtLab(Bool_t kind) // Check if it is correct !!!
{
    // Return the azimuthal angle of the virtual photon in Lab frame, for the
    // particle in the row k of the EVNT bank.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    Double_t phi_virt;

    if (PhiLab(0,kind) > 0) phi_virt = - 180 + PhiLab(0,kind);
    else phi_virt = 180 + PhiLab(0,kind);

    return phi_virt;
}



Double_t TIdentificator::ThetaPQ(Int_t k, Bool_t kind)
{
    // Return the polar angle of the born particle in respect to virtual
    // photon direction, for the particle in the row k of the EVNT bank. It
    // doesn't apply for electron.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.
    //
    // ---------N.B.------ This is actually not ThetaPQ, but ThetaLab...
    // Should be fixed at some point... But need to check first whether it is 
    // used in any other methods

    if (kind == 0) {
        return acos(Pz(k) / Momentum(k));
    } else {                            // Fix this in case kind != 1
        return acos(Pz(k,1) / Momentum(k,1));
    }
}



Double_t TIdentificator::PhiPQ(Int_t k, Bool_t kind)
{
    // Return the azimuthal angle of the born particle in respect to virtual
    // photon direction, for the particle in the row k of the EVNT bank. It
    // doesn't apply for electron.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    Double_t phi_pq;

    if (kind == 0) {
        TVector3 vpi(Px(k), Py(k), Pz(k));
        TVector3 vvirt(-Px(0), -Py(0), kEbeam - Pz(0));
        Double_t phi_z = TMath::Pi() - vvirt.Phi();
        vvirt.RotateZ(phi_z);
        vpi.RotateZ(phi_z);
        TVector3 vhelp(0., 0., 1.);
        Double_t phi_y = vvirt.Angle(vhelp);
        vvirt.RotateY(phi_y);
        vpi.RotateY(phi_y);
        phi_pq = vpi.Phi() * 180 / (TMath::Pi());
    } else {                            // Fix this in case kind != 1
        TVector3 vpi(Px(k,1), Py(k,1), Pz(k,1));
        TVector3 vvirt(-Px(0,1), -Py(0,1), kEbeam - Pz(0,1));
        Double_t phi_z = TMath::Pi() - vvirt.Phi();
        vvirt.RotateZ(phi_z);
        vpi.RotateZ(phi_z);
        TVector3 vhelp(0., 0., 1.);
        Double_t phi_y = vvirt.Angle(vhelp);
        vvirt.RotateY(phi_y);
        vpi.RotateY(phi_y);
        phi_pq = vpi.Phi() * 180 / (TMath::Pi());
    }

    return phi_pq;
}



Double_t TIdentificator::CosThetaPQ(Int_t k, Bool_t kind)
{
    // Return the cosine of ThetaPQ, for the particle in the row k of the EVNT
    // bank. It doesn't apply for electron.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    if (kind == 0)
        return (Pz(k) * (kEbeam - Pz(0)) - Px(k) * Px(0) - Py(k) * Py(0)) /
                            (sqrt(Nu() * Nu() + Q2()) * Momentum(k));
    else                                // Fix this in case kind != 1
        return (Pz(k,1) * (kEbeam - Pz(0,1)) - Px(k,1) * Px(0,1) -
                Py(k,1) * Py(0,1)) /
                            (sqrt(Nu(1) * Nu(1) + Q2(1)) * Momentum(k,1));
}



Double_t TIdentificator::PTrans2PQ(Int_t k, Bool_t kind)
{
    // Return the momentum transverse component squared of the born particle
    // in respect to virtual photon direction, for the particle in the row k
    // of the EVNT bank. It doesn't apply for electron.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    if (kind == 0)
        return Momentum(k) * Momentum(k) *
                            (1 - CosThetaPQ(k) * CosThetaPQ(k));
    else                                // Fix this in case kind != 1
        return Momentum(k,1) * Momentum(k,1) *
                            (1 - CosThetaPQ(k,1) * CosThetaPQ(k,1));
}



Double_t TIdentificator::PLong2PQ(Int_t k, Bool_t kind)
{
    // Return the momentum longitudinal component squared of the born particle
    // in respect to virtual photon direction, for the particle in the row k
    // of the EVNT bank. It doesn't apply for electron.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    if (kind == 0)
        return Momentum(k) * Momentum(k) * CosThetaPQ(k) * CosThetaPQ(k);
    else                                // Fix this in case kind != 1
        return Momentum(k,1) * Momentum(k,1) * CosThetaPQ(k,1) * CosThetaPQ(k,1);
}



Int_t TIdentificator::Sector(Int_t k, Bool_t kind) // Check if it is correct !!! Add k==1
{
    // Return the sector of the CLAS detector where the particle was detected,
    // for the particle in the row k of the EVNT bank.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    if ( kind == 0) {
        if (PhiLab(k) != 330.)
            return int((PhiLab(k) + 90.) / 60.) - 1;
        else return 5;
    } else {
        if (PhiLab(k,1) != 330.)
            return int((PhiLab(k,1) + 90.) / 60.) - 1;
        else return 5;
    }
}



Double_t TIdentificator::Q2(Bool_t kind)
{
    // Return the four-momentum transfer of the electron-nucleon interaction.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    if (kind == 0) {
        return 4. * kEbeam * Momentum(0) *
                            sin(ThetaLab(0)/2) * sin(ThetaLab(0)/2);
    } else {                            // Fix this in case kind != 1
        return 4. * kEbeam * Momentum(0,1) *
                            sin(ThetaLab(0,1)/2) * sin(ThetaLab(0,1)/2);
    }
}



Double_t TIdentificator::W(Bool_t kind)
{
    // Return the invariant mass of the electron-nucleon interaction.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    if (kind == 0) {
        return sqrt(kMassProton * kMassProton + 2 * kMassProton * Nu() - Q2());
    } else {                            // Fix this in case kind != 1
        return sqrt(kMassProton * kMassProton + 2 * kMassProton * Nu(1) - Q2(1));
    }
}



Double_t TIdentificator::Nu(Bool_t kind)
{
    // Return the energy transfer of the electron-nucleon interaction.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    if (kind == 0) {
        return kEbeam - Momentum(0);
    } else {                            // Fix this in case kind != 1
        return kEbeam - Momentum(0,1);
    }
}



Double_t TIdentificator::Xb(Bool_t kind)
{
    if (kind == 0)
        return Q2(0) / (2 * Nu(0) * kMassProton);
    else
        return Q2(1) / (2 * Nu(1) * kMassProton);
}



Double_t TIdentificator::Yb(Bool_t kind)
{
    if (kind == 0)
        return Nu(0) / kEbeam;
    else
        return Nu(1) / kEbeam;
}



Double_t TIdentificator::ZhPi(Int_t k, Double_t Mass, Bool_t kind) // name needs to be switched
{
    // Return the energy fraction of the born particle, for the particle in
    // the row k of the EVNT bank. It doesn't apply for electron.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    if (kind == 0)
        return sqrt(Mass * Mass + Momentum(k) * Momentum(k)) / Nu(0);
    else                                // Fix this in case kind != 1
        return sqrt(Mass * Mass + Momentum(k,1) * Momentum(k,1)) / Nu(1);
}



Double_t TIdentificator::TimeCorr4(Double_t mass, Int_t k)
{
    return (PathSC(0)/30.) - TimeSC(0) + TimeSC(k) - 0.08 -
                (PathSC(k) / 30.) * sqrt(pow(mass/Momentum(k),2) + 1);
}



Double_t TIdentificator::FidTheta(Int_t k, Bool_t kind)
{
    Double_t fid_theta_val;

    if (kind == 0)
    {
        TVector3 v3p(Px(k), Py(k), Pz(k));
        fid_theta_val = v3p.Theta() * 180 / TMath::Pi();
    } else {
        TVector3 v3p(Px(k,1), Py(k,1), Pz(k,1));
        fid_theta_val = v3p.Theta() * 180 / TMath::Pi();
    }

    return fid_theta_val;
}



Double_t TIdentificator::FidThetaMin()
{
    Int_t sector = FidSector(0);

    Double_t theta_min_val = kThetaPar0[sector] +
            kThetaPar1[sector] / pow(Momentum(0),2) +
            kThetaPar2[sector] * Momentum(0) +
            kThetaPar3[sector] / Momentum(0) +
            kThetaPar4[sector] *exp(kThetaPar5[sector] * Momentum(0));

    return theta_min_val;
}



Double_t TIdentificator::FidThetaMinPiPlus(Int_t k)
{
    Int_t sector = FidSector(k);

    Double_t theta_min_val = kThetaPar0PiPlus[sector] +
            kThetaPar1PiPlus[sector] / pow(Momentum(k), 2) +
            kThetaPar2PiPlus[sector] * Momentum(k) +
            kThetaPar3PiPlus[sector] / Momentum(k) +
            kThetaPar4PiPlus[sector] * exp(kThetaPar5PiPlus[sector] * Momentum(k));

    return theta_min_val;
}



Double_t TIdentificator::FidThetaMinPiMinus(Int_t k)
{
  Int_t sector = FidSector(k);

    Double_t theta_min_val = kThetaPar0PiMinus[sector] +
      kThetaPar1PiMinus[sector] / pow(Momentum(k), 2) +
      kThetaPar2PiMinus[sector] * Momentum(k) +
      kThetaPar3PiMinus[sector] / Momentum(k) +
      kThetaPar4PiMinus[sector] * exp(kThetaPar5PiMinus[sector] * Momentum(k));

    return theta_min_val;
}



Double_t TIdentificator::FidFunc(Int_t side, Int_t param)
{
    Int_t sector = FidSector(0);
    Double_t fid_func_val = 0.0; // dummy value to avoid that uninitialized warning

    if (side == 0 && param==0)
        fid_func_val = kFidPar0Low0[sector] +
                    kFidPar0Low1[sector] * exp(kFidPar0Low2[sector] *
                            (Momentum(0) - kFidPar0Low3[sector]));
    else if (side == 1 && param==0)
        fid_func_val = kFidPar0High0[sector] +
                    kFidPar0High1[sector] * exp(kFidPar0High2[sector] *
                            (Momentum(0) - kFidPar0High3[sector]));
    else if (side == 0 && param==1)
        fid_func_val=kFidPar1Low0[sector] +
                    kFidPar1Low1[sector] * Momentum(0) *
                    exp(kFidPar1Low2[sector] * pow((Momentum(0) -
                                kFidPar1Low3[sector]),2));
    else if (side == 1 && param==1)
        fid_func_val = kFidPar1High0[sector] +
                    kFidPar1High1[sector] * Momentum(0) *
                    exp(kFidPar1High2[sector] * pow((Momentum(0) -
                                kFidPar1High3[sector]),2));

    return fid_func_val;
}



Double_t TIdentificator::FidFuncPiPlus(Int_t side, Int_t param, Int_t k)
{
    Int_t sector = FidSector(k);
    Double_t fid_func_val_pip = 0.0; // dummy value to avoid that uninitialized warning

    if (side == 0 && param == 0)
        fid_func_val_pip = kFidPar0Low0PiPlus[sector] +
                    kFidPar0Low1PiPlus[sector] * exp(kFidPar0Low2PiPlus[sector] *
                            (Momentum(k) - kFidPar0Low3PiPlus[sector]));
    else if (side == 1 && param == 0)
        fid_func_val_pip = kFidPar0High0PiPlus[sector] +
                    kFidPar0High1PiPlus[sector] * exp(kFidPar0High2PiPlus[sector] *
                            (Momentum(k) - kFidPar0High3PiPlus[sector]));
    else if (side == 0 && param == 1)
        fid_func_val_pip = kFidPar1Low0PiPlus[sector] +
                    kFidPar1Low1PiPlus[sector] * Momentum(k) *
                    exp(kFidPar1Low2PiPlus[sector] * pow((Momentum(k) -
                                kFidPar1Low3PiPlus[sector]), 2));
    else if (side == 1 && param == 1)
        fid_func_val_pip = kFidPar1High0PiPlus[sector] +
                    kFidPar1High1PiPlus[sector] * Momentum(k) *
                    exp(kFidPar1High2PiPlus[sector] * pow((Momentum(k) -
                                kFidPar1High3PiPlus[sector]), 2));

    return fid_func_val_pip;
}



Double_t TIdentificator::FidFuncPiMinus(Int_t side, Int_t param, Int_t k)
{
  Int_t sector = FidSector(k);
  Double_t fid_func_val_pim = 0.0; // dummy value to avoid that uninitialized warning

  if (side == 0 && param == 0)
    fid_func_val_pim = kFidPar0Low0PiMinus[sector] -
      kFidPar0Low1PiMinus[sector] * atan(kFidPar0Low2PiMinus[sector] *
					 (Momentum(k) - kFidPar0Low3PiMinus[sector]));
  else if (side == 1 && param == 0)
    fid_func_val_pim = kFidPar0High0PiMinus[sector] -
      kFidPar0High1PiMinus[sector] * atan(kFidPar0High2PiMinus[sector] *
                                         (Momentum(k) - kFidPar0High3PiMinus[sector]));
    
  else if (side == 0 && param == 1)
    fid_func_val_pim = kFidPar1Low0PiMinus[sector] +
      kFidPar1Low1PiMinus[sector] * Momentum(k) *
      exp(kFidPar1Low2PiMinus[sector] * pow((Momentum(k) -
					     kFidPar1Low3PiMinus[sector]), 2));
  else if (side == 1 && param == 1)
    fid_func_val_pim = kFidPar1High0PiMinus[sector] +
      kFidPar1High1PiMinus[sector] * Momentum(k) *
      exp(kFidPar1High2PiMinus[sector] * pow((Momentum(k) -
					      kFidPar1High3PiMinus[sector]), 2));
  
  return fid_func_val_pim;
}



Double_t TIdentificator::FidPhi(Int_t k, Bool_t kind)
{
    Double_t fid_phi_val;

    if (kind == 0) {
        TVector3 v3p(Px(k), Py(k), Pz(k));
        fid_phi_val = v3p.Phi() * 180 / TMath::Pi();
    } else {
        TVector3 v3p(Px(k,1), Py(k,1), Pz(k,1));
        fid_phi_val = v3p.Phi() * 180 / TMath::Pi();
    }

    if (fid_phi_val < -30)
        fid_phi_val += 360;
    else if (fid_phi_val > 330)
        fid_phi_val -= 360;

    return fid_phi_val;
}



Double_t TIdentificator::FidPhiMin()
{
    Int_t sector = FidSector(0);
    Double_t fid_phi_min_val;

    if (FidTheta(0) <= FidThetaMin()) {
        fid_phi_min_val = 60. * sector;
        return fid_phi_min_val;
    } else {
        fid_phi_min_val = 60. * sector - FidFunc(0,0) *
                (1 - 1 / (1 + (FidTheta(0) - FidThetaMin()) / FidFunc(0,1)));
        return fid_phi_min_val;
    }
}



Double_t TIdentificator::FidPhiMax()
{
    Int_t sector = FidSector(0);
    Double_t fid_phi_max_val;

    if (FidTheta(0) <= FidThetaMin()){
        fid_phi_max_val = 60. * sector;
        return fid_phi_max_val;
    } else {
        fid_phi_max_val = 60. * sector + FidFunc(1,0) *
                (1 - 1 / (1 + (FidTheta(0) - FidThetaMin()) / FidFunc(1,1)));
        return fid_phi_max_val;
    }
}



Double_t TIdentificator::FidPhiMinPiPlus(Int_t k)
{
    Int_t sector = FidSector(k);

    Double_t fid_phi_min_val;

//    if (FidTheta(k) <= FidThetaMinPiPlus(k) || FidTheta(k) >= kFidThetaMax)
    if (FidTheta(k) <= FidThetaMinPiPlus(k)) {
        fid_phi_min_val = 60. * sector;
    } else {
        fid_phi_min_val = 60. * sector - FidFuncPiPlus(0,0,k) *
                (1 - 1 / (1 + (FidTheta(k) - FidThetaMinPiPlus(k)) / FidFuncPiPlus(0,1,k)));
    }

    return fid_phi_min_val;
}



Double_t TIdentificator::FidPhiMaxPiPlus(Int_t k)
{
    Int_t sector = FidSector(k);
    Double_t fid_phi_max_val;

//    if (FidTheta(CT, k) <= FidThetaMinPiPlus(k) || FidTheta(k) >= kFidThetaMax)
    if (FidTheta(k) <= FidThetaMinPiPlus(k)) {
        fid_phi_max_val = 60. * sector;
    } else {
        fid_phi_max_val = 60. * sector + FidFuncPiPlus(1,0,k) *
                (1 - 1 / (1 + (FidTheta(k) - FidThetaMinPiPlus(k)) / FidFuncPiPlus(1,1,k)));
    }

    return fid_phi_max_val;
}



Double_t TIdentificator::FidPhiMinPiMinus(Int_t k)
{
  Int_t sector = FidSector(k);

  Double_t fid_phi_min_val;

  if (FidTheta(k) <= FidThetaMinPiMinus(k)) {
    fid_phi_min_val = 60. * sector;
  } else {
    fid_phi_min_val = 60. * sector - FidFuncPiMinus(0,0,k) *
      (1 - 1 / (1 + (FidTheta(k) - FidThetaMinPiMinus(k)) / FidFuncPiMinus(0,1,k)));
  }

  return fid_phi_min_val;
}



Double_t TIdentificator::FidPhiMaxPiMinus(Int_t k)
{
  Int_t sector = FidSector(k);
  Double_t fid_phi_max_val;

  if (FidTheta(k) <= FidThetaMinPiMinus(k)) {
    fid_phi_max_val = 60. * sector;
  } else {
    fid_phi_max_val = 60. * sector + FidFuncPiMinus(1,0,k) *
      (1 - 1 / (1 + (FidTheta(k) - FidThetaMinPiMinus(k)) / FidFuncPiMinus(1,1,k)));
  }

  return fid_phi_max_val;
}



Bool_t TIdentificator::FidCheckCut()
{
    if (FidTheta(0) > FidThetaMin() &&
                FidPhi(0) > FidPhiMin() &&
                FidPhi(0) < FidPhiMax())
        return 1;                               // Fiducial Cut passed
    else
        return 0;                               // Fiducial Cut not passed
}



Bool_t TIdentificator::FidCheckCutPiPlus(Int_t k)
{
//    if (FidTheta(CT, k) > FidThetaMinPiPlus(CT, k) &&
//            FidTheta(k) < fid_theta_max &&
//            FidPhi(k) > FidPhiMinPiPlus(CT, k) &&
//            FidPhi(k) < FidPhiMaxPiPlus(CT, k))
//        return 1;

    if (FidTheta(k) > FidThetaMinPiPlus(k) &&
            FidPhi(k) > FidPhiMinPiPlus(k) &&
            FidPhi(k) < FidPhiMaxPiPlus(k))
        return 1;                               // Fiducial Cut passed
    else
        return 0;                               // Fiducial Cut not passed
}



Bool_t TIdentificator::FidCheckCutPiMinus(Int_t k)
{

  if (FidTheta(k) > FidThetaMinPiMinus(k) &&
      FidPhi(k) > FidPhiMinPiMinus(k) &&
      FidPhi(k) < FidPhiMaxPiMinus(k))
    return 1;                               // Fiducial Cut passed
  else
    return 0;                               // Fiducial Cut not passed

}



Int_t TIdentificator::FidSector(Int_t k, Bool_t kind)
{
    Int_t sector;

    if (kind == 0) {
        if (FidPhi(k) != 330) {
            sector = int((FidPhi(k) + 90) / 60) - 1;
            return sector;
        } else {
            return 5;
        }
    }
    else {
        if (FidPhi(k,1) != 330) {
            sector = int((FidPhi(k,1) + 90) / 60) - 1;
            return sector;
        } else {
            return 5;
        }
    }
}



Int_t TIdentificator::ElecVertTarg()
{
    Int_t p_vertex_cut_elec = 0;
    Double_t ele_liq_lim[6][2];
    Double_t ele_sol_low[6];

    ele_liq_lim[0][0] = -32.5;
    ele_liq_lim[0][1] = -28;
    ele_liq_lim[1][0] = -32.5;
    ele_liq_lim[1][1] = -27.5;
    ele_liq_lim[2][0] = -32;
    ele_liq_lim[2][1] = -27.25;
    ele_liq_lim[3][0] = -32;
    ele_liq_lim[3][1] = -27.75;
    ele_liq_lim[4][0] = -32.5;
    ele_liq_lim[4][1] = -28.35;
    ele_liq_lim[5][0] = -33.5;
    ele_liq_lim[5][1] = -28.75;

    Double_t ele_sol_high = -20;

    ele_sol_low[0] = -26.5;
    ele_sol_low[1] = -26.;
    ele_sol_low[2] = -25.65;
    ele_sol_low[3] = -25.85;
    ele_sol_low[4] = -26.65;
    ele_sol_low[5] = -27.15;

    Int_t n_sector = Sector(0);

    if (Z(0) >= ele_liq_lim[n_sector][0] && Z(0) <= ele_liq_lim[n_sector][1])
        p_vertex_cut_elec = 1;
    if (Z(0) >= ele_sol_low[n_sector] && Z(0) <= ele_sol_high)
        p_vertex_cut_elec = 2;

    return p_vertex_cut_elec;
}

Double_t TIdentificator::Z_Corrected(Int_t k, TString particle){
  
  Double_t CorrectedZ;
  
  const Float_t sol_pos = -25;
  const Float_t epar1 = -24.728;
  const Float_t epar2 = 0.316;
  const Float_t epar3 = 283.54;
  
  Float_t evres(0);
  
  Int_t n_sector = Sector(k);
  Double_t theta = FidTheta(k);
  Double_t phi = FidPhi(k);
  
  if(n_sector<0 || n_sector>5){
    CorrectedZ = Z(k);
  }
  else if(particle.CompareTo("electron")==0){
    
    CorrectedZ = Z(k) - ( epar1 - (epar2*TMath::Cos((phi-epar3)*TMath::DegToRad())/TMath::Tan(theta*TMath::DegToRad())) );
    CorrectedZ += sol_pos;
    
    CorrectedZ *= ( EZCorrPhi[n_sector][0] +
		    EZCorrPhi[n_sector][1]*pow(phi,1) +
		    EZCorrPhi[n_sector][2]*pow(phi,2) +
		    EZCorrPhi[n_sector][3]*pow(phi,3) );
    
    CorrectedZ *= ( EZCorrTheta[n_sector][0] +
                    EZCorrTheta[n_sector][1]*pow(theta,1) +
                    EZCorrTheta[n_sector][2]*pow(theta,2) +
                    EZCorrTheta[n_sector][3]*pow(theta,3) );
  }
  else if (particle.CompareTo("proton")==0){

    CorrectedZ = Z(k) - ( epar1 - (epar2*TMath::Cos((phi-epar3)*TMath::DegToRad())/TMath::Tan(theta*TMath::DegToRad())) );
    CorrectedZ += sol_pos;

    CorrectedZ *= ( PZCorrPhi[n_sector][0] +
                    PZCorrPhi[n_sector][1]*pow(phi,1) +
                    PZCorrPhi[n_sector][2]*pow(phi,2) +
                    PZCorrPhi[n_sector][3]*pow(phi,3) );

    CorrectedZ *= ( PZCorrTheta[n_sector][0] +
                    PZCorrTheta[n_sector][1]*pow(theta,1) +
                    PZCorrTheta[n_sector][2]*pow(theta,2) +
                    PZCorrTheta[n_sector][3]*pow(theta,3) );
  }
  else{
    CorrectedZ = Z(k);
  }
  
  return CorrectedZ;

}

/*
Int_t TIdentificator::ElecVertTargCorrected()
{
    Int_t p_vertex_cut_elec = 0;
    Double_t CorrectedZ = Z_Corrected(0, "electron");

    if (CorrectedZ >= -30.5 && CorrectedZ <= -26.5)
       p_vertex_cut_elec = 1;
    if (CorrectedZ >= -24.5 && CorrectedZ <= -20)
        p_vertex_cut_elec = 2;

    return p_vertex_cut_elec;
}
*/


Bool_t TIdentificator::PionVertTarg(Int_t k)
{
    Bool_t vertex_cut_pion = 0;
    Double_t pion_liq_low;
    Double_t pion_liq_high;
    Int_t n_ele_sector = Sector(0);
    Int_t n_pion_sector = Sector(k);

    if (n_pion_sector == 5 || (n_ele_sector == 3 && n_pion_sector == 4) ||
                (n_pion_sector == 0 && n_ele_sector != 1 && n_ele_sector != 4))
        pion_liq_low = -36.;
    else pion_liq_low = -35.;

    if (n_ele_sector == 3 && n_pion_sector == 2)
        pion_liq_high = -24.;
    else if ((n_ele_sector == 5 && n_pion_sector != 2 && n_pion_sector != 3) ||
                (n_pion_sector == 5 && n_ele_sector != 2) ||
                (n_ele_sector == 0 && n_pion_sector == 0) ||
                (n_ele_sector == 1 && n_pion_sector == 1) ||
                (n_pion_sector == 4 && (n_ele_sector == 3 || n_ele_sector == 4)))
        pion_liq_high = -26.;
    else
        pion_liq_high = -25.;

    if (ElecVertTarg() == 1 && Z(k) >= pion_liq_low && Z(k) <= pion_liq_high)
        vertex_cut_pion = 1;

    if (ElecVertTarg() == 2 && Z(k) >= -30 && Z(k) <= -18)
        vertex_cut_pion = 1;

    return vertex_cut_pion;
}

Double_t TIdentificator::Q2_Corrected(Bool_t kind)
{
    // Return the four-momentum transfer of the electron-nucleon interaction.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

  if (kind == 0) {
    return 4. * kEbeam_arc * Momentum_Corrected(0) *
      sin(Theta_Corrected(0)*TMath::DegToRad()/2.) * sin(Theta_Corrected(0)*TMath::DegToRad()/2.); 
  } else {                            // Fix this in case kind != 1
    return 4. * kEbeam_arc * Momentum(0,1) *
      sin(ThetaLab(0,1)/2) * sin(ThetaLab(0,1)/2);
  }
}



Double_t TIdentificator::W_Corrected(Bool_t kind)
{
    // Return the invariant mass of the electron-nucleon interaction.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    if (kind == 0) {
      return sqrt(kMassProton * kMassProton + 2. * kMassProton * Nu_Corrected() - Q2_Corrected());
    } else {                            // Fix this in case kind != 1
      return sqrt(kMassProton * kMassProton + 2. * kMassProton * Nu_Corrected(1) - Q2_Corrected(1));
    }
}



Double_t TIdentificator::Nu_Corrected(Bool_t kind)
{
    // Return the energy transfer of the electron-nucleon interaction.
    //
    // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
    // instead.

    if (kind == 0) {
        return kEbeam_arc - Momentum_Corrected(0);
    } else {                            // Fix this in case kind != 1
        return kEbeam_arc - Momentum(0,1);
    }
}


Double_t TIdentificator::Xb_Corrected(Bool_t kind)
{
    if (kind == 0)
        return Q2_Corrected(0) / (2 * Nu_Corrected(0) * kMassProton);
    else
        return Q2_Corrected(1) / (2 * Nu_Corrected(1) * kMassProton);
}



Double_t TIdentificator::Yb_Corrected(Bool_t kind)
{
    if (kind == 0)
        return Nu_Corrected(0) / kEbeam_arc;
    else
        return Nu_Corrected(1) / kEbeam_arc;
}


Double_t TIdentificator::CosThetaPQ_Corrected(Int_t k, Bool_t kind)
{
  // Return the cosine of ThetaPQ, for the particle in the row k of the EVNT
  // bank. It doesn't apply for electron.
  //
  // If kind is zero, the EVNT bank is used. If not, the GSIM bank is used
  // instead.
  // N.B. Px(),Py(),Pz() do not have the momentum or angle correction applied.
  // ...so I put it in manually for the calculation here.
  
  if (kind == 0){
    
    //Trigger Particle Px,Py,Pz corrected for Angle and Momentum
    Float_t tz_corr = Momentum_Corrected(0) * cos(Theta_Corrected(0)*TMath::DegToRad());
    Float_t t_alpha = TMath::Sqrt( (Momentum_Corrected(0)*Momentum_Corrected(0) - tz_corr*tz_corr) 
				   / ( Px(0)*Px(0) + Py(0)*Py(0) ) );
    Float_t tx_corr = t_alpha * Px(0);
    Float_t ty_corr = t_alpha * Py(0);

    //Particle in row k Px,Py,Pz corrected for Angle and Momentum
    Float_t pz_corr = Momentum_Corrected(k) * cos(Theta_Corrected(k)*TMath::DegToRad());
    Float_t p_alpha = TMath::Sqrt( (Momentum_Corrected(k)*Momentum_Corrected(k) - pz_corr*pz_corr)
                                   / ( Px(k)*Px(k) + Py(k)*Py(k) ) );
    Float_t px_corr = p_alpha * Px(k);
    Float_t py_corr = p_alpha * Py(k);
    
    
    return ( (pz_corr * (kEbeam_arc - tz_corr) - px_corr * tx_corr - py_corr * ty_corr) / 
	     (sqrt(Nu_Corrected() * Nu_Corrected() + Q2_Corrected()) * Momentum_Corrected(k)) );
  
  }
  else                  // Fix this in case kind != 1
    return ( (Pz(k,1) * (kEbeam_arc - Pz(0,1)) - Px(k,1) * Px(0,1) - Py(k,1) * Py(0,1))/
	     (sqrt(Nu(1) * Nu(1) + Q2(1)) * Momentum(k,1)));
  
}


Double_t TIdentificator::Momentum_Corrected(Int_t k)
{
  //Return corrected Momentum Magnitude (in GeV/c) for
  //a given azimuthal and polar angle. This correction is only for
  //valid for DIS electrons (at least for now...). So, electrons with
  //other kinematics and other particles will not have their measured
  //momenta changed by this routine.

  Double_t mom_corr;
  Int_t n_sector = Sector(k);
  Double_t momentum = Momentum(k);
  Double_t phi = FidPhi(k);
  Double_t theta = Theta_Corrected(k);

  if( (n_sector<0 || n_sector>5) || (k!=0) || (W()<1.6 || Xb()>0.75) )
    mom_corr = momentum;
  else{
    Float_t factor = ( MomentumCorrPhi[n_sector][0] +
		       MomentumCorrPhi[n_sector][1]*pow(phi,1) +
		       MomentumCorrPhi[n_sector][2]*pow(phi,2) +
		       MomentumCorrPhi[n_sector][3]*pow(phi,3) );
    
    factor *= ( MomentumCorrTheta[n_sector][0] +
		MomentumCorrTheta[n_sector][1]*pow(theta,1) +
		MomentumCorrTheta[n_sector][2]*pow(theta,2) +
		MomentumCorrTheta[n_sector][3]*pow(theta,3) );
    
    mom_corr = momentum * factor;
  }
    
  return mom_corr;
}



Double_t TIdentificator::Theta_Corrected(Int_t k)
{
  //Return the corrected theta angle (in degrees) for a given
  //azimuthal angle.
  //N.B. The correction was fit using electrons and protons from theta of ~15-55 degrees
  //...but the dependence on theta was negligible. So, the correction is only a
  //...function of phi, and should apply to all particles (except for neutrals, I suppose)
  //...and for all momentum vectors (i.e. all angles).

  Double_t theta_corr;
  Int_t n_sector = Sector(k);
  Double_t phi = FidPhi(k);
  Double_t theta = FidTheta(k);
  
  if( (n_sector<0 || n_sector>5) || Charge(k)==0)
    theta_corr = theta;
  else{
    Float_t delta_phi = ( ThetaCorrection[n_sector][0] +
			  ThetaCorrection[n_sector][1]*pow(phi,1) +
			  ThetaCorrection[n_sector][2]*pow(phi,2) +
			  ThetaCorrection[n_sector][3]*pow(phi,3));
    
    theta_corr = theta + delta_phi;
  }
  
  return theta_corr ;
}


/*
Double_t TIdentificator::Z_Good(Int_t k)
{
  //Return the z vertex after the theta correction in each sector

  Double_t dtheta = (TMath::Pi()/180.) * (FidTheta(k) - Theta_Corrected(k)); //In radians
  Double_t phi = FidPhi(k); //In degrees

  const Double_t shift = .317; //In cm
  const Double_t phi0 = 284.8; //In degrees

  Double_t z_good = Z(k) + ( (shift/sin(Theta_Corrected(k)*TMath::Pi()/180.)) * abs(cos((phi-phi0)*TMath::Pi()/180.)) * dtheta );

  return z_good ;
}

Double_t TIdentificator::Z_Better(Int_t k)
{
  //Return the z vertex after the theta correction in each sector
  
  Double_t theta = FidTheta(k); //In degrees
  Double_t theta_corr = Theta_Corrected(k); //In degrees
  Double_t phi = FidPhi(k); //In degrees
  
  const Double_t shift = .317; //In cm
  const Double_t phi0 = 284.8; //In degrees
  
  Double_t z_better = Z(k) + ( ( (1./tan(theta_corr*TMath::Pi()/180.)) - (1./tan(theta*TMath::Pi()/180.)) ) * shift * abs(cos((phi-phi0)*TMath::Pi()/180.)) );
  
  return z_better ;
}
*/

#include "Categorize.C"

